---
phase: 02-core-screens
plan: 01
type: execute
---

<objective>
Create state management infrastructure: GameState enum, PlayerData model, and PlayerStore for persistence.

Purpose: Enable navigation flow and player data tracking across all screens.
Output: Complete state management ready for screen implementations.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@PLAYBOOK_CONDENSED.md

**Prior plans:**
- 01-01: Xcode project created
- 01-02: BennieColors, BennieTypography available
- 01-03: ChildFriendlyButton, WoodButton, WoodSign, ProgressBar available

**Existing files:**
@BennieGame/BennieGame/App/AppCoordinator.swift (has basic GameState enum)
@BennieGame/BennieGame/App/BennieGameApp.swift

**Tech available:** SwiftUI, SwiftData, Lottie
**Design constraints:** German UI only, 2 players (Alexander, Oliver)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand GameState and create ActivityType enums</name>
  <files>BennieGame/Core/State/GameState.swift</files>
  <action>
Create comprehensive state machine:

```swift
enum GameState: Equatable {
    case loading
    case playerSelection
    case home
    case activitySelection(ActivityType)
    case playing(ActivityType, SubActivity)
    case levelComplete
    case celebrationOverlay(coinsEarned: Int)
    case treasureScreen
    case videoSelection
    case videoPlaying(minutesRemaining: Int)
    case parentGate
    case parentDashboard
}

enum ActivityType: String, CaseIterable {
    case raetsel = "Rätsel"
    case zahlen = "Zahlen"
    case zeichnen = "Zeichnen"  // Locked
    case logik = "Logik"        // Locked

    var isLocked: Bool {
        self == .zeichnen || self == .logik
    }
}

enum SubActivity {
    // Rätsel
    case puzzleMatching
    case labyrinth
    // Zahlen
    case wuerfel
    case waehleZahl
}
```

Update AppCoordinator.swift to use the new GameState from this file.
  </action>
  <verify>Project builds; all states accessible via AppCoordinator</verify>
  <done>GameState enum has all 12 states; ActivityType has 4 activities with locked property</done>
</task>

<task type="auto">
  <name>Task 2: Create PlayerData model and PlayerStore</name>
  <files>BennieGame/Core/State/PlayerData.swift, BennieGame/Core/State/PlayerStore.swift</files>
  <action>
Create PlayerData model (Codable for UserDefaults persistence):

```swift
struct PlayerData: Codable, Identifiable, Equatable {
    let id: String  // "alexander" or "oliver"
    let name: String
    var coins: Int
    var totalCoinsEarned: Int
    var lastPlayedDate: Date?

    static let alexander = PlayerData(
        id: "alexander",
        name: "Alexander",
        coins: 0,
        totalCoinsEarned: 0
    )

    static let oliver = PlayerData(
        id: "oliver",
        name: "Oliver",
        coins: 0,
        totalCoinsEarned: 0
    )
}
```

Create PlayerStore (@Observable for SwiftUI):

```swift
@Observable
final class PlayerStore {
    private(set) var players: [PlayerData]
    private(set) var activePlayer: PlayerData?

    private let storageKey = "bennie.players"

    init() {
        players = [.alexander, .oliver]
        load()
    }

    func selectPlayer(id: String)
    func awardCoin()
    func spendCoins(_ amount: Int) -> Bool
    private func save()
    private func load()
}
```

Use UserDefaults for persistence (NOT SwiftData - keep it simple for this phase).
  </action>
  <verify>Can create PlayerStore; can select player; coins persist after simulated restart</verify>
  <done>PlayerData and PlayerStore created; persistence works via UserDefaults</done>
</task>

<task type="auto">
  <name>Task 3: Wire up AppCoordinator with PlayerStore</name>
  <files>BennieGame/App/AppCoordinator.swift, BennieGame/App/BennieGameApp.swift</files>
  <action>
Update AppCoordinator to:
1. Import GameState from Core/State
2. Hold reference to PlayerStore
3. Add navigation methods:
   - `navigateHome()`
   - `navigateToActivity(_ type: ActivityType)`
   - `handleLevelComplete()`
   - `checkCelebration() -> Bool` (returns true if coins % 5 == 0)

Update BennieGameApp to:
1. Create AppCoordinator as @State
2. Create PlayerStore as @State
3. Inject both into environment
4. Update ContentView to use coordinator state for view switching

ContentView should switch views based on coordinator.currentState:
- .loading → LoadingView() (placeholder for now)
- .playerSelection → PlayerSelectionView() (placeholder)
- .home → HomeView() (placeholder)
- default → placeholder text

Add placeholder views that just show the state name for now.
  </action>
  <verify>App launches; can manually set coordinator state in debugger; view switches based on state</verify>
  <done>AppCoordinator integrated with PlayerStore; view routing works based on GameState</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Project builds without errors
- [ ] GameState has all 12 states defined
- [ ] ActivityType has 4 activities with correct locked status
- [ ] PlayerData persists to UserDefaults
- [ ] AppCoordinator can transition between states
- [ ] ContentView routes to correct placeholder based on state
</verification>

<success_criteria>
- All tasks completed
- State management infrastructure ready
- Player data persists correctly
- Navigation routing works
- Project compiles successfully
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-screens/02-01-SUMMARY.md`

The summary should note: "State management complete, ready for screen implementations"
</output>
